pipeline {
  agent any
	environment { 
        mvnHome = tool 'Maven_Config'
		
		// GitHub setup
		workingGitURL= 'https://github.com/CA-MMISDigitalServices/Dev.git'     
		workingBranch= 'dockerDeploy'
		
		//POM file locations for Maven
		workingPOM = '/var/lib/jenkins/workspace/TestPipelineDocker/SpringPOC'
		
		// Jenkins setup 
		workingJob= 'TestPipelineDocker'
		workingProject= 'SpringPOC'
		workingJenkinsDir= '/var/lib/jenkins/workspace'
		
		// AWS code Deploy setup
		AWSCDapplicationName= 'SpringPOCDocker'
		AWSCDDeploymentGroupName= 'SpringPOCDockerDG'
		AWSCDSubDirectory= 'SpringPOC'
		
		// Jira project setup
		workingJiraProject ='PTP'
    }
	stages {
		stage('Preparation') {
			steps {
//				git url: 'https://github.com/CA-MMISDigitalServices/Dev.git', branch: 'docker'
				git url: "${workingGitURL}", branch: "${workingBranch}"
			}
		}
		stage('Build War') {
            steps {
//				sh "'${mvnHome}/bin/mvn' -X -B --file D:/Software/Install/jenkins/workspace/TestPipeline/SpringPOC/pom.xml -Dmaven.test.failure.ignore clean install"
				sh "'${mvnHome}/bin/mvn' -X -B --file '${workingPOM}' -Dmaven.test.failure.ignore clean install cobertura:cobertura -Dcobertura.report.format=xml"
                }
            post {
                always {
                    echo 'Build War always'
                }
				failure {
					echo 'Build War failure'
				}
				success {
					echo 'Build War success'
				} 
            }
        }
		stage('Docker Build Image') {
			steps {
				script {
					echo 'Docker Build'
					sh "pwd" 
				
					// Setup version tag.
					def pom = readMavenPom file: "${workingJenkinsDir}/${workingJob}/${workingProject}/pom.xml"
					def version = pom.version.replace("-SNAPSHOT", ".${currentBuild.number}")
					echo "version : ${version}"
					
					def (major, minor, increment, buildnum) = version.tokenize('.')
					echo  "After tokenize major ${major}"

					def tagVersion = major + '.' + minor + '.' + increment + '.SNAPSHOT'
					echo "tagVersion :  ${tagVersion}"
				
					sh "docker build -f SpringPOC/Dockerfile  -t trinitytg/springpoc:${tagVersion} /var/lib/jenkins/workspace/TestPipelineDocker/SpringPOC"
				}
			}	
		}
		stage('Docker Push') {
			steps {
				withCredentials([usernamePassword(credentialsId: 'dockerhub', passwordVariable: 'dockerhubPassword', usernameVariable: 'dockerhubUser')]) {
					script {
					
						// Remove all docker images from local repos.
						
			//		    sh "docker rmi '$(docker images -q)'"
						
						echo "hubuser : ${env.dockerhubUser}" 
						echo "hubpass : ${env.dockerhubPassword}" 
					
						// Setup version tag.
						def pom = readMavenPom file: "${workingJenkinsDir}/${workingJob}/${workingProject}/pom.xml"
						def version = pom.version.replace("-SNAPSHOT", ".${currentBuild.number}")
						echo "version : ${version}"
					
						def (major, minor, increment, buildnum) = version.tokenize('.')
						echo  "After tokenize major ${major}"

						def tagVersion = major + '.' + minor + '.' + increment + '.SNAPSHOT'
						echo "tagVersion :  ${tagVersion}"
						
						_cdir="${workingJenkinsDir}/${workingJob}/${workingProject}/scripts"
						echo "working dir is : $_cdir"
					
//						sh "sed -i -e 's/dummyUser/${env.dockerhubUser}/g' '$_cdir/startup.sh'"
//						sh "sed -i -e 's/dummyPass/${env.dockerhubPassword}/g' '_cdir/startup.sh'"
//						sh "sed -i -e 's/dummyTag/${tagVersion}/g' '$_cdir/startup.sh'"

//						sh "docker commit -m 'Updated springpoc' -a 'Jenkins Build' springpoc trinitytg/springpoc:${tagVersion}"
						
//						sh "docker tag springpoc trinitytg/springpoc:${tagVersion}"
					
						sh "docker login -u ${env.dockerhubUser} -p ${env.dockerhubPassword}"
						
						sh "docker push trinitytg/springpoc:${tagVersion}"
//						sh "docker push trinitytg/springpoc"
					}
				}
			}
		}
		stage('AWS Code Deploy') {
			steps {
				echo 'AWS Code Deploy'
				echo "env.AWS_ACCESS_KEY_ID :" + env.AWS_ACCESS_KEY_ID
				echo "env.AWS_SECRET_ACCESS_KEY :" + env.AWS_SECRET_ACCESS_KEY
				
				step([$class: 'AWSCodeDeployPublisher', 
						applicationName: "${AWSCDapplicationName}",
						awsAccessKey: env.AWS_ACCESS_KEY_ID,
						awsSecretKey: env.AWS_SECRET_ACCESS_KEY, 
						credentials: 'awsAccessKey', 
						deploymentConfig: 'CodeDeployDefault.OneAtATime', 
						deploymentGroupAppspec: false, 
						deploymentGroupName: "${AWSCDDeploymentGroupName}", 
						deploymentMethod: 'deploy', 
						excludes: '/target**, src/**, .settings/**', 
						iamRoleArn: '', 
						includes: '**', 
						pollingFreqSec: 15, 
						pollingTimeoutSec: 300, 
						proxyHost: '', 
						proxyPort: 0, 
						region: 'us-gov-west-1', 
						s3bucket: 'codedeploybucket', 
						s3prefix: '', 
						subdirectory: "${AWSCDSubDirectory}",
						versionFileName: '', 
						waitForCompletion: true])
			
			}
			post {
                always {
					echo 'AWS Code Deploy'
                }	
				failure {
					script {
						echo 'AWS Code Deploy  failure'
						testIssue = [fields: [ project: [key: "${workingJiraProject}"],
									summary: 'Jenkins Build Failure.',
									description: "Jenkins Build Failed - AWS Code Deploy Failed-  Job name: '${env.JOB_NAME} - Build Number: ${env.BUILD_NUMBER}  URL: ${env.BUILD_URL}'",
									priority: [name: 'Highest'],
									issuetype: [name: 'Bug']]]

						response = jiraNewIssue issue: testIssue, site: 'CAMMIS'

						echo response.successful.toString()
						echo response.data.toString()
						
						slackSend (color: '#FFFF00', message: "Failed: Job - AWS Code Deploy Failed '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})")
					}
				}
				success {
					echo 'AWS Code Deploy Success'
					slackSend (color: '#00FF00', message: "Code Deploy SUCCESSFUL: Job '${env.JOB_NAME} [${env.BUILD_NUMBER}]' (${env.BUILD_URL})")
				}
			}		
		}		
	}
}